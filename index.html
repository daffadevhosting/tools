<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Javascript Obfuscator (Browser)</title>
  <style>
    body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin: 16px; background:#0f172a; color:#e6eef8; }
    .container { max-width: 1100px; margin: 0 auto; }
    textarea { width: 100%; height: 260px; resize: vertical; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; background:#021026; color:#dff; border:1px solid #123; padding:12px; border-radius:6px; }
    .row { display:flex; gap:12px; margin-top:12px; }
    .col { flex:1; min-width:0; }
    .panel { background:#07122a; padding:12px; border-radius:8px; border:1px solid #123; }
    label { display:block; font-size:13px; margin-bottom:6px; color:#9fb2d6; }
    button { background:#0ea5a3; border:none; color:#012; padding:8px 12px; border-radius:6px; cursor:pointer; }
    button.secondary { background:#f59e0b; color:#04111a; }
    .status { margin-top:8px; font-size:13px; color:#9fb2d6; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; }
    .control { display:flex; align-items:center; gap:8px; }
    input[type="number"] { width:80px; padding:6px; border-radius:6px; border:1px solid #234; background:#041827; color:#dff; }
    input[type="checkbox"] { width:16px; height:16px; }
    .small { font-size:12px; color:#8fb0d6; }
  </style>
</head>
<body>
  <div class="container">
    <h2>Javascript Obfuscator — Browser Edition</h2>
    <div class="row">
      <div class="col panel">
        <label for="inputCode">Input JavaScript</label>
        <textarea id="inputCode" placeholder="// masukkan kode JS di sini"></textarea>
        <div class="controls" style="margin-top:8px;">
          <button id="btnObfuscate">Obfuscate</button>
          <button id="btnLoadExample" class="secondary">Load Example</button>
          <button id="btnClear">Clear</button>
          <button id="btnCopy">Copy Output</button>
        </div>
        <div id="status" class="status"></div>
      </div>

      <div class="col panel">
        <label>Options</label>
        <div class="control"><input type="checkbox" id="optCompact" checked> <span class="small">Compact (remove whitespace)</span></div>
        <div class="control"><input type="checkbox" id="optMangle" checked> <span class="small">Identifier Mangle (scope-aware)</span></div>
        <div class="control"><input type="checkbox" id="optStrings" checked> <span class="small">String Array + Decoder</span></div>
        <div class="control"><input type="checkbox" id="optControl" checked> <span class="small">Control Flow Flattening</span></div>
        <div class="control"><input type="checkbox" id="optDead" checked> <span class="small">Dead Code Injection</span></div>
        <div class="control"><input type="checkbox" id="optDebug" checked> <span class="small">Debug Protection</span></div>
        <label class="small" style="margin-top:8px;">Tuning</label>
        <div class="control"><label class="small">String threshold</label><input type="number" id="strThreshold" value="0.6" min="0" max="1" step="0.1"></div>
        <div class="control"><label class="small">Dead code ratio</label><input type="number" id="deadRatio" value="0.12" min="0" max="0.5" step="0.01"></div>
        <div style="margin-top:12px;">
          <label class="small">Output</label>
          <textarea id="outputCode" readonly placeholder="// hasil obfuscation akan muncul di sini"></textarea>
        </div>
      </div>
    </div>
  </div>

<script>
/*
  Obfuscator: Browser single-file
  - Worker created from Blob
  - Worker imports Acorn, acorn-walk, Astring via importScripts
  - AST transforms: rename, strings->array, simple flattening
  - This is a strong baseline for in-browser obfuscation
*/

class ProObfuscatorUI {
  constructor() {
    this.worker = null;
    this.initWorker();
    this.hookUI();
  }

  initWorker() {
    const workerCode = this.getWorkerCode();
    const blob = new Blob([workerCode], { type: 'application/javascript' });
    this.worker = new Worker(URL.createObjectURL(blob));
    this.worker.onmessage = (e) => {
      const { type, payload } = e.data;
      if (type === 'result') {
        document.getElementById('outputCode').value = payload.code;
        document.getElementById('status').textContent = 'Selesai — hasil siap.';
      } else if (type === 'error') {
        document.getElementById('status').textContent = 'Error: ' + payload;
      } else if (type === 'progress') {
        document.getElementById('status').textContent = payload;
      }
    };
    this.worker.onerror = (err) => {
      document.getElementById('status').textContent = 'Worker error: ' + err.message;
    };
  }

  getOptionsFromUI() {
    return {
      compact: !!document.getElementById('optCompact').checked,
      mangle: !!document.getElementById('optMangle').checked,
      strings: !!document.getElementById('optStrings').checked,
      controlFlow: !!document.getElementById('optControl').checked,
      deadCode: !!document.getElementById('optDead').checked,
      debugProtection: !!document.getElementById('optDebug').checked,
      strThreshold: parseFloat(document.getElementById('strThreshold').value),
      deadRatio: parseFloat(document.getElementById('deadRatio').value),
    };
  }

  hookUI() {
    document.getElementById('btnObfuscate').addEventListener('click', () => this.obfuscate());
    document.getElementById('btnLoadExample').addEventListener('click', () => this.loadExample());
    document.getElementById('btnClear').addEventListener('click', () => this.clear());
    document.getElementById('btnCopy').addEventListener('click', () => this.copyOutput());
  }

  obfuscate() {
    const code = document.getElementById('inputCode').value;
    if (!code.trim()) {
      document.getElementById('status').textContent = 'Masukkan kode JS dulu.';
      return;
    }
    const options = this.getOptionsFromUI();
    document.getElementById('status').textContent = 'Memproses...';
    this.worker.postMessage({ type: 'obfuscate', payload: { code, options } });
  }

  loadExample() {
    const example = `// Example
function greeter(name) {
  const greeting = "Hello, " + name + "!";
  console.log(greeting);
  return greeting;
}

class MathUtil {
  sum(a, b) {
    return a + b;
  }
}

greeter('User');
`;
    document.getElementById('inputCode').value = example;
    document.getElementById('status').textContent = 'Example loaded.';
  }

  clear() {
    document.getElementById('inputCode').value = '';
    document.getElementById('outputCode').value = '';
    document.getElementById('status').textContent = '';
  }

  copyOutput() {
    const out = document.getElementById('outputCode').value;
    if (!out.trim()) { document.getElementById('status').textContent = 'Tidak ada output.'; return; }
    navigator.clipboard.writeText(out).then(() => {
      document.getElementById('status').textContent = 'Output disalin ke clipboard.';
    }, () => {
      document.getElementById('status').textContent = 'Gagal menyalin. Browser mungkin tidak mendukung API clipboard.';
    });
  }

 getWorkerCode() {
    return `
        // --- Inject ACORN core ---
        ${ACORN_CODE}

        // --- Inject ACORN-WALK ---
        ${ACORN_WALK_CODE}

        self.onmessage = async (e) => {
            const { code, options } = e.data;

            try {
                const result = obfuscate(code, options);
                self.postMessage({ type: "ok", code: result });
            } catch (err) {
                self.postMessage({ type: "error", error: err.message });
            }
        };

        function obfuscate(input, opt) {
            const ast = acorn.parse(input, { ecmaVersion: "latest", sourceType: "module" });

            const varMap = new Map();
            let counter = 0;

            walk.simple(ast, {
                VariableDeclarator(node) {
                    if (!varMap.has(node.id.name)) {
                        varMap.set(node.id.name, "_v" + (counter++));
                    }
                }
            });

            let out = input;
            // Apply variable mangling
            for (const [orig, mang] of varMap) {
                out = out.replace(new RegExp("\\\\b" + orig + "\\\\b", "g"), mang);
            }

            return out;
        }
    `;
}

const {parse} = acorn;
const walk = acornWalk;
const {generate} = astring;

// util: generate short names _0, _1, _2...
function makeNameGenerator() {
  const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
  let counter = 0;
  return function next() {
    let n = counter++;
    let s = '';
    do {
      s = chars[n % chars.length] + s;
      n = Math.floor(n / chars.length) - 1;
    } while (n >= 0);
    return '_' + s;
  };
}

// scope-aware identifier renamer
function mangleIdentifiers(ast) {
  // We build lexical scopes using a simple walk; this handles functions and blocks.
  const nameGen = makeNameGenerator();
  const scopeStack = [];

  function enterScope() {
    scopeStack.push({decls: new Map(), used: new Set()});
  }
  function exitScope() {
    scopeStack.pop();
  }
  function declare(name) {
    const s = scopeStack[scopeStack.length - 1];
    if (!s.decls.has(name)) {
      s.decls.set(name, nameGen());
    }
  }
  function lookup(name) {
    for (let i = scopeStack.length - 1; i >= 0; i--) {
      const s = scopeStack[i];
      if (s.decls.has(name)) return s.decls.get(name);
    }
    return null;
  }

  // first pass: collect declarations (var/let/const, function params, function names)
  walk.fullAncestor(ast, (node, ancestors) => {
    const top = ancestors[ancestors.length - 1];
    switch (node.type) {
      case 'Program':
      case 'BlockStatement':
      case 'FunctionDeclaration':
      case 'FunctionExpression':
      case 'ArrowFunctionExpression':
        // scopes are handled in second pass; noop here
        break;
    }
  });

  // second pass: traverse and manage scope manually for renaming
  function transform(node, ancestors) {
    let isNewScope = false;
    if (node.type === 'Program' || node.type === 'BlockStatement' ||
        node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' ||
        node.type === 'ArrowFunctionExpression') {
      enterScope();
      isNewScope = true;
      // collect params and function name (if declared)
      if (node.type === 'FunctionDeclaration' && node.id && node.id.name) {
        declare(node.id.name);
      }
      if ((node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression') && node.params) {
        node.params.forEach(p => {
          if (p && p.type === 'Identifier') declare(p.name);
          // Note: not handling patterns here (rest, destructuring) in this baseline
        });
      }
    }

    // collect declarations
    if (node.type === 'VariableDeclaration') {
      node.declarations.forEach(decl => {
        if (decl.id && decl.id.type === 'Identifier') declare(decl.id.name);
      });
    }
    if (node.type === 'FunctionDeclaration' && node.id && node.id.type === 'Identifier') {
      declare(node.id.name);
    }

    // rename identifiers usage
    if (node.type === 'Identifier') {
      // determine if this identifier is a property key or labeled position; skip some contexts
      const parent = ancestors[ancestors.length - 2];
      const parentKey = parent && Object.keys(parent).find(k => parent[k] === node || (Array.isArray(parent[k]) && parent[k].includes(node)));

      // skip property keys like obj.prop, property names, labels, import/export
      const skipContexts = ['Property', 'MemberExpression', 'BreakStatement', 'ContinueStatement', 'LabeledStatement', 'ImportSpecifier', 'ExportSpecifier'];
      if (parent && parent.type === 'MemberExpression' && parent.property === node && !parent.computed) {
        return;
      }
      if (parent && parent.type === 'Property' && parent.key === node && !parent.computed) {
        return;
      }
      if (parent && (parent.type === 'BreakStatement' || parent.type === 'ContinueStatement' || parent.type === 'LabeledStatement')) return;
      if (parent && (parent.type === 'ImportSpecifier' || parent.type === 'ExportSpecifier' || parent.type === 'ImportDefaultSpecifier')) return;
      if (parent && parent.type === 'FunctionDeclaration' && parent.id === node) {
        // declaration handled
        return;
      }
      // Try to lookup replacement from nearest scope
      const newName = lookup(node.name);
      if (newName) {
        node.name = newName;
      }
    }

    // traverse children
    for (const key in node) {
      if (!node.hasOwnProperty(key)) continue;
      const val = node[key];
      if (Array.isArray(val)) {
        val.forEach((child) => {
          if (child && typeof child.type === 'string') transform(child, ancestors.concat(node));
        });
      } else if (val && typeof val.type === 'string') {
        transform(val, ancestors.concat(node));
      }
    }

    if (isNewScope) exitScope();
  }

  transform(ast, []);
  return ast;
}

// extract strings into array and replace literals with decoder call
function extractStrings(ast, threshold = 0.6) {
  // collect string nodes
  const strings = [];
  walk.full(ast, node => {
    if (node.type === 'Literal' && typeof node.value === 'string') {
      strings.push(node);
    }
  });

  // Choose a subset based on threshold
  const selected = [];
  strings.forEach((node) => {
    if (Math.random() < threshold) selected.push(node);
  });

  if (selected.length === 0) return { ast, preamble: '' };

  // create array var name
  const arrName = '_$s';
  const enc = (s) => btoa(unescape(encodeURIComponent(s))); // base64 encoding safe for unicode

  // build string array and decoder function AST insertion as preamble code text
  const arrLiteral = '[' + selected.map(n => '"' + enc(n.value) + '"').join(',') + ']';
  const decoder = \`
(function(__arr,__d){
  function __dec(i){
    var v = __arr[i];
    try{ return decodeURIComponent(escape(atob(v))); }catch(e){ return atob(v); }
  }
  return function(i){ return __dec(i); };
})(\${arrName}, null)\`;
  // We'll prepend: var _$s = [ "...", "..."]; function _d(i){ ... }
  const preamble = 'var ' + arrName + '=' + arrLiteral + ';' +
                   'function _d(i){try{return decodeURIComponent(escape(atob(' + arrName + '[i])));}catch(e){return atob(' + arrName + '[i]);}};';

  // replace selected nodes with CallExpression _d(index)
  let idx = 0;
  selected.forEach(node => {
    const replacement = {
      type: 'CallExpression',
      callee: { type: 'Identifier', name: '_d' },
      arguments: [{ type: 'Literal', value: idx }]
    };
    // mutate node in-place
    Object.keys(node).forEach(k => delete node[k]);
    Object.assign(node, replacement);
    idx++;
  });

  return { ast, preamble };
}

// simple control flow flattening: wrap top-level statements in array & switch dispatcher
function flattenControlFlow(ast) {
  // Only apply at Program body level (top-level)
  const body = ast.body;
  if (!Array.isArray(body) || body.length < 3) return ast;

  // create array of functions representing statements
  const fnName = '_$f'; // function array name
  const dispatcherName = '_$r'; // runner var

  const wrappedFns = body.map((stmt, i) => {
    return {
      type: 'ExpressionStatement',
      expression: {
        type: 'AssignmentExpression',
        operator: '=',
        left: {
          type: 'MemberExpression',
          computed: true,
          object: { type: 'Identifier', name: fnName },
          property: { type: 'Literal', value: i }
        },
        right: {
          type: 'FunctionExpression',
          id: null,
          params: [],
          body: { type: 'BlockStatement', body: [stmt] }
        }
      }
    };
  });

  // create initialization: var _$f = []; then populate
  const init = {
    type: 'VariableDeclaration',
    kind: 'var',
    declarations: [{
      type: 'VariableDeclarator',
      id: { type: 'Identifier', name: fnName },
      init: { type: 'ArrayExpression', elements: [] }
    }]
  };

  // create runner loop: var i=0; while(i< N){ _$f[i++](); }
  const runner = {
    type: 'ExpressionStatement',
    expression: {
      type: 'CallExpression',
      callee: {
        type: 'FunctionExpression',
        id: null,
        params: [],
        body: {
          type: 'BlockStatement',
          body: [
            {
              type: 'VariableDeclaration',
              kind: 'var',
              declarations: [{ type: 'VariableDeclarator', id: { type: 'Identifier', name: dispatcherName }, init: { type: 'Literal', value: 0 } }]
            },
            {
              type: 'WhileStatement',
              test: {
                type: 'BinaryExpression',
                operator: '<',
                left: { type: 'Identifier', name: dispatcherName },
                right: { type: 'Literal', value: body.length }
              },
              body: {
                type: 'BlockStatement',
                body: [
                  {
                    type: 'ExpressionStatement',
                    expression: {
                      type: 'CallExpression',
                      callee: {
                        type: 'MemberExpression',
                        computed: true,
                        object: { type: 'Identifier', name: fnName },
                        property: { type: 'UpdateExpression', operator: '++', argument: { type: 'Identifier', name: dispatcherName }, prefix: false }
                      },
                      arguments: []
                    }
                  }
                ]
              }
            }
          ]
        }
      }
    }
  };

  // new AST body: init, wrappedFns..., runner
  ast.body = [init, ...wrappedFns, runner];
  return ast;
}

// inject dead code: opaque predicate based
function injectDeadCode(ast, ratio = 0.12) {
  // We'll insert "if (0 && <complex expr>) { ... }" patterns before some function declarations
  const random = Math.random;
  const insertions = [];
  walk.full(ast, node => {
    if ((node.type === 'FunctionDeclaration' || node.type === 'BlockStatement') && random() < ratio) {
      const deadIf = {
        type: 'IfStatement',
        test: { type: 'Literal', value: false },
        consequent: {
          type: 'BlockStatement',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'CallExpression',
                callee: { type: 'MemberExpression', computed: false, object: { type: 'Identifier', name: 'console' }, property: { type: 'Identifier', name: 'log' } },
                arguments: [{ type: 'Literal', value: 'dead:' + Math.floor(random() * 1000000) }]
              }
            }
          ]
        },
        alternate: null
      };
      insertions.push({ atNode: node, snippet: deadIf });
    }
  });

  // perform insertion before the target node where possible (only top-level program body supported cleanly)
  if (ast.body && ast.body.length) {
    const newBody = [];
    ast.body.forEach(n => {
      newBody.push(n);
      for (const ins of insertions) {
        if (ins.atNode === n) {
          newBody.push(ins.snippet);
        }
      }
    });
    if (newBody.length) ast.body = newBody;
  }
  return ast;
}

// debug protection injection (lightweight)
function injectDebugProtectionCode(preamble) {
  const guard = \`
(function(){
  var _t = function(){};
  // Basic devtools detection using toString length & timing
  try {
    var start = Date.now();
    debugger;
    var end = Date.now();
    if (end - start > 100) {
      // if debugger paused, break
      while(false){}
    }
  } catch(e){}
})();\n\`;
  return guard + preamble;
}

// compacting/minify done by removing whitespace in final generated string (simple)
function compactCode(code) {
  // Leave newlines in strings untouched because code is generated by astring (safe)
  return code.replace(/\\s+;/g, ';').replace(/\\s+\\{/g,'{').replace(/\\{\\s+/g,'{').replace(/\\s+\\}/g,'}').replace(/;\\s+/g,';').replace(/\\s+\\(/g,'(').replace(/\\s+\\)/g,')');
}

// main pipeline
function pipeline(code, options) {
  try {
    postMessage({ type: 'progress', payload: 'Parsing code...' });
    const ast = parse(code, { ecmaVersion: 2020, sourceType: 'module' });

    if (options.mangle) {
      postMessage({ type: 'progress', payload: 'Mangle identifiers...' });
      mangleIdentifiers(ast);
    }

    let preamble = '';

    if (options.strings) {
      postMessage({ type: 'progress', payload: 'Extract strings...' });
      const res = extractStrings(ast, options.strThreshold || 0.6);
      // res.preamble contains var and decoder function text
      if (res.preamble) preamble += res.preamble;
    }

    if (options.controlFlow) {
      postMessage({ type: 'progress', payload: 'Flatten control flow...' });
      flattenControlFlow(ast);
    }

    if (options.deadCode) {
      postMessage({ type: 'progress', payload: 'Inject dead code...' });
      injectDeadCode(ast, options.deadRatio || 0.12);
    }

    // generate code
    postMessage({ type: 'progress', payload: 'Generating code...' });
    let out = generate(ast);

    // prepend preamble if any
    if (preamble) out = preamble + '\\n' + out;

    if (options.debugProtection) {
      out = injectDebugProtectionCode(out);
    }

    if (options.compact) {
      out = compactCode(out);
    }

    return { code: out };
  } catch (err) {
    return { error: String(err) };
  }
}

self.onmessage = function(e) {
  const { type, payload } = e.data;
  if (type === 'obfuscate') {
    const { code, options } = payload;
    const res = pipeline(code, options || {});
    if (res.error) {
      postMessage({ type: 'error', payload: res.error });
    } else {
      postMessage({ type: 'result', payload: { code: res.code } });
    }
  }
};
    `;
  }
}

const ob = new ProObfuscatorUI();

// Load acorn library code (raw string)
const ACORN_CODE = `
${await (await fetch("https://cdn.jsdelivr.net/npm/acorn@8.11.3/dist/acorn.js")).text()}
`;

// Load acorn-walk
const ACORN_WALK_CODE = `
${await (await fetch("https://cdn.jsdelivr.net/npm/acorn-walk@8.3.1/dist/acorn-walk.js")).text()}
`;
</script>
</body>
</html>